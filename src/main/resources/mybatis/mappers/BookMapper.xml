<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.team01.book.dao.BookDao">


    <select id="selectAllBook" resultType="BookVO">
        select   trim("bookId") as "bookId"
             , "bookCateNm"
             , "bookCateDepth"
             , "bookName"
             , "bookDesc"
             , "author"
             , "bookPrice"
             , "stock"
             , "stockStatus"
             , "publishDate"
             , "roleId"
             , "cateId"
             , "bookImgPath"
             , "writer"
             , "createDate"
        from book
    </select>

    <select id="selectOneBook" resultType="BookVO" parameterType="String">
        select   trim("bookId") as "bookId"
             , "bookCateNm"
             , "bookCateDepth"
             , "bookName"
             , "bookDesc"
             , "author"
             , "bookPrice"
             , "stock"
             , "stockStatus"
             , "publishDate"
             , "roleId"
             , "cateId"
             , "bookImgPath"
             , "writer"
             , "createDate"
        from book
        where "bookId"=${bookId}
    </select>
    <!-- 인덱스 역할을 하는 파라미터를 String으로 하면 #{} 이 인식을 못할 경우 , ${} 사용하기
    마이바티스가 #{}바인딩 변수를 사용해서 문자열을 치환하면 varchar 타입으로 변환해 char 타입일 경우 인식이
    안될 수도 있음. ==> cast 사용해도 안되는 경우에는 ??
    -->
    <insert id="createBook" parameterType="BookVO">
        <selectKey keyProperty="bookId" resultType="String" order="BEFORE">
            SELECT BOOK_SECQUENCE.NEXTVAL FROM DUAL
        </selectKey>

        INSERT INTO BOOK (
        "bookId"
        , "bookCateNm"
        , "bookCateDepth"
        , "bookName"
        , "bookDesc"
        , "author"
        , "bookPrice"
        , "stock"
        , "stockStatus"
        , "publishDate"
        , "roleId"
        , "cateId"
        , "bookImgPath"
        , "writer"

        ) VALUES (
        #{bookId}
        , #{bookCateNm}
        , #{bookCateDepth}
        , #{bookName}
        , #{bookDesc}
        , #{author}
        , #{bookPrice}
        , #{stock}
        , #{stockStatus}
        , #{publishDate}
        , #{roleId}
        , #{cateId}
       ,#{bookImgPath}
        , #{writer}
        )

    </insert>
    <!-- 도서 존재유뮤 유효성검사 쿼리 -->
    <select id="existBooks" parameterType="list" resultType="string">
        SELECT trim("bookId") as "bookId"
        FROM BOOK
        WHERE trim("bookId") IN
        <foreach collection="bookIds" item="bookId" open="(" separator="," close=")">
            #{bookId}
        </foreach>
    </select>
    <!--  도서존재유무 유효성 검사 후 존재하고 있는 데이터 삭제 쿼리   -->
    <delete id="deleteBooks" parameterType="list">
        DELETE FROM book
        WHERE trim("bookId") IN
        <foreach collection="existBookIds" item="bookId" open="(" separator="," close=")">
           #{bookId}
        </foreach>
    </delete>


    <!-- collection은 List<String> 타입으로 받아온 리스트 문자열 타입 파라미터명을 입력 -->
</mapper>
<!-- ** 오라클 char 타입과 마이바티스 String 타입은 varchar  **   -->
<!--
responseEntity로 테이터를 받아 마이바티스로 넘겨받아 데이터베이스로 들어갈 때, String 타입은 varchar 타입으로 변환되기 때문에
오라클에서 char 타입인 경우에는 ${}인 바인딩 변수로 받아서 넘겨야 되며
, char타입은 도메인 형식에 따른 크기가 고정이기때문에 나머지 공백은 trim()함수로 제거해주어야 한다
결론, 오라클 문자열은  varchar2를 주로 사용하는 이유(varchr2는 남은 크기가 공백으로 변하면 자동으로 공백제거) 이며,
함수를 연산했을 경우에는 값만 존재하기때문에 '별칭' 설정하여 컬럼명을 명시적으로 설정해줘야 함
${}바인딩 변수를 사용하면 SQL Injection에 취약하므로 db 타입을 varchar로 설정해 #{} 바인딩 변수를 사용해 SQL Injection을 방지하자..!
-->
